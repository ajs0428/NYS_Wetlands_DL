---
title: "Project Info for NYS Wetlands and GHG Estimation"
format: html
project: 
    execute-dir: project
---


```{r}
#| label: setup

library(terra)
library(sf)
library(MultiscaleDTM)
library(foreach)
library(doParallel)
library(here)
library(tidyverse)
suppressPackageStartupMessages(library(tidyterra))

terraOptions(memfrac = 0.25,
             tempdir = "/ibstorage/anthony/NYS_Wetlands_GHG/Data/tmp")

```

```{r}
here::here()
```


Training data generation 

```{r}

```


## DEM and Image Processing

To process the large amount of data including both digital elevation models (DEMs) and aerial imagery from the National Agricultural Imagery Program (NAIP), We sought to organize NYS into regions using proximity clusters on watersheds. In particular we used hydrologic unit code (HUC) 12 boundaries. 


```{r}
#ny_hucs <- vect("Data/NY_HUCS/NY_HUCS_08_6350_Cluster.gpkg")
set.seed(11)
ny_hucs <- st_read(here("Data/NY_HUCS/NY_HUCS_08_6350_Cluster.gpkg")) #|> 
    # dplyr::filter(areasqkm < 900)
ny_hucs_full <- dplyr::filter(ny_hucs, !st_is_empty(ny_hucs))

centers <- ny_hucs_full |> 
  st_centroid() |> 
  dplyr::mutate(dplyr::as_tibble(st_coordinates(geom))) |> 
    dplyr::filter(!is.na(X))

km <- kmeans(centers |>
               st_drop_geometry() |>
               dplyr::select(X, Y), 
             centers = 250)

ny_hucs_clust <- ny_hucs_full |> 
  dplyr::mutate(cluster = km$cluster) |> 
    dplyr::select(name, huc12, cluster, tnmid) |> 
    sf::st_transform("EPSG:26918")
#sf::st_write(ny_hucs_clust, "/ibstorage/anthony/NYS_Wetlands_GHG/Data/NY_HUCS/NY_Cluster_Zones_200.gpkg", append = FALSE) 

ny_hucs_100 <- ny_hucs_clust[ny_hucs_clust$cluster == 208,]
plot(ny_hucs_clust["cluster"])
plot(ny_hucs_100["name"])
```

Each cluster of HUC 12s will be used to guide DEM and image processing programs. Where: 
- The program subsets a virtual raster dataset using the cluster ID
- Within the cluster, imagery/DEMs are aggregated for each HUC 12
- Terrain metrics are then calculated for each HUC 12 
- The outputs are saved and can be mosaic'd back together if needed. 



DEM Indexing
- We can use the clusters to subset out the indexes and DEM file names from the vector shapefiles provided by NYS GIS
- There are a lot of overlapping feature polygons so combining into one polygon is infeasible
- Instead how can a HUC cluster be used to identify DEM indexes in the list?
- Function could: 
    - Check for overlap across the list 
    - Crop/extract the features of each one separately
    - Extract the filenames of the corresponding rasters
    
First, make sure everything is in the same projection

```{r}

st_list <- (lapply(list.files(here("Data/NYS_DEM_Indexes"), pattern = ".shp$",full.names = TRUE), sf::st_read))

transform_sf <- function(stl){
    new_stl <- list()
    for(i in seq_along(stl)){
        if(crs(stl[[i]]) != st_crs("EPSG:6347")){
            new_stl[[i]] <- st_transform(stl[[i]], st_crs("EPSG:6347"))
        } else {
            new_stl[[i]] <- stl[[i]]
        }
    }
    return(new_stl)
}

st_list_trs <- transform_sf(st_list)
for(i in st_list_trs) {print(st_crs(i)$input)}

```


Test out a cluster
- Cluster 56, in the ADK
- 22 geometries
```{r}
test_clust <- ny_hucs_clust |> 
    dplyr::filter(cluster == "208") 

ggplot() + 
    geom_sf(data = st_list_trs[[1]], aes(fill = YEAR)) +
    geom_sf(data = st_list_trs[[2]], aes(fill = YEAR)) +
    geom_sf(data = st_list_trs[[3]], aes(fill = YEAR)) +
    geom_sf(data = st_list_trs[[4]], aes(fill = YEAR)) +
    geom_sf(data = st_list_trs[[5]], aes(fill = YEAR)) +
    geom_sf(data = test_clust, aes(fill = "huc12")) 

```


This is a list of all DEM files downloaded from NYGIS 

```{r}
dem_file_list <- list.files(here("Data/DEMs"), 
                            pattern = ".img$|.tif$", 
                            full.names = TRUE, 
                            recursive = TRUE, 
                            include.dirs = TRUE)

length(dem_file_list)

```


Missing NY DEM Indexes from lidar acquisitions yet to be processed 

```{r}
sort(unique(vect(here("Data/NY_HUCS/Missing_DEM_Indexes_HUCS.gpkg"))$cluster))
```


Cluster extraction function
```{r}
cluster_extract <- function(cluster, dem_indexes){
    files_to_extract <- list()
    for(i in seq_along(dem_indexes)){
        dems_in <- dem_indexes[[i]] |> st_filter(y = cluster, .predicate = st_intersects)
        if(nrow(dems_in) > 1){
            Fnames <- dems_in["FILENAME"][[1]]
            files_to_extract <- append(files_to_extract, Fnames)
        } else {
            next
        }
    }
    return(files_to_extract)
}

```



We make a function to take a cluster and for every HUC 12 watershed, 
- Run the cluster extract to get a list of filenames for the DEMs. 
- create a `spatrastercollection` or `sprc` from the filenames 
- merge them together and crop to create a new DEM wiuth watershed boundaries 


```{r}
huc_extract <- function(cluster){
    f_list <- list() # list of lists of filenames 
    v_list <- list() # list for HUC vectors
    for(i in seq_along(cluster$huc12)){
        dem_to_extr <- cluster_extract(cluster = cluster[i, ], dem_indexes = dem_ind_trs)
        f_list[[i]] <- dems_file_list[basename(dems_file_list) %in% dem_to_extr]
        v_list[[i]] <- terra::vect(cluster[i,]) |>
            terra::project(crs("EPSG:6347")) |> terra::wrap()
    }
    
    # list of lists of spatrasterCollections
    r_list <- foreach(i = seq_along(cluster$huc12),
                      .packages = c("terra", "tidyterra", "sf"),
                      .export = "args") %dopar% {
        f_list[[i]] |> 
            as.list() |> 
            lapply(terra::rast) |> 
            terra::sprc() |> 
            terra::merge() |>
            terra::mask(mask = terra::unwrap(v_list[[i]]), updatevalue = NA, touches = TRUE,
                        filename = paste0(args[5], "cluster_", args[3], "_huc_", cluster[["huc12"]][[i]],".tif"),
                        overwrite = TRUE) #|>
            #terra::wrap()
        #return(rs)
    }
    #return(list(f_list,lapply(v_list, terra::unwrap), lapply(r_list, terra::unwrap)))
}


```



```{r}
#| eval: false
test_clust3 <- test_clust[1:3,]

huc_extract(cluster = cluster_target)
```

```{r}
#| cache: true
test_dems <- rast(here("Data/TerrainProcessed/HUC_DEMs/cluster_208_huc_041402011002.tif"))

plet(terra::shade(terra::terrain(test_dems, "slope", unit = "radians"), terra::terrain(test_dems, "aspect", unit = "radians")), 
     col=grey(0:100/100))


```



Terrain metric processing


```{r}

terrain_function <- function(list_of_dem_rasts, cluster, metric = args[4]){
    cl <- makeCluster(4)
    registerDoParallel(cl)
    
    win <- c(as.numeric(args[5]), as.numeric(args[5]))
    
    foreach(i = seq_along(list_of_dem_rasts), 
            .packages = c("terra", "tidyterra"),
            .export = "args") %dopar% {
                
        cluster_huc_name <- stringr::str_remove(basename(list_of_dem_rasts[i]), ".tif")
        dems_target <- list_of_dem_rasts[[i]]
        
        if(stringr::str_detect(metric, "slp")){
            dems_target |> 
                terra::rast() |> 
                MultiscaleDTM::SlpAsp(w = win, unit = "degrees", 
                                      include_scale = TRUE, metrics = "slope",
                                      filename = paste0(args[3], cluster_huc_name, "_terrain_", args[4],"win",args[5], ".tif"),
                                      overwrite = TRUE) 
        } else if (stringr::str_detect(metric, "dmv")){
            dems_target |> 
                terra::rast() |> 
                MultiscaleDTM::DMV(w = win, stand = "none", # I think "none" so that NA won't be produced
                                   include_scale = TRUE,
                                      filename = paste0(args[3], cluster_huc_name, "_terrain_", args[4],"win",args[5], ".tif"),
                                      overwrite = TRUE) 
        } else if(stringr::str_detect(metric, "curv")){
            dems_target |> 
                terra::rast() |> 
                MultiscaleDTM::Qfit(w = win,
                                    include_scale = TRUE, metrics = c("meanc", "planc", "profc"),
                                    filename = paste0(args[3], cluster_huc_name, huc_name, "_terrain_", args[4],"win",args[5], ".tif"),
                                    overwrite = TRUE)
        } else {
            print("No terrain metric specified or not identified")
        }
    }
    stopCluster(cl)
}
    
```


But we can use filtering to get faster computation
```{r}
terrain_function <- function(list_of_dem_rasts, cluster, metric = args[4]){
    cl <- makeCluster(8)
    registerDoParallel(cl)
    
    foreach(i = seq_along(list_of_dem_rasts), 
            .packages = c("terra", "tidyterra"),
            .export = "args") %dopar% {
                
        cluster_huc_name <- stringr::str_remove(basename(list_of_dem_rasts[[i]]), ".tif")
        dems_target <- list_of_dem_rasts[[i]]
        
        if(stringr::str_detect(metric, "slp")){
            dems_target |> 
                terra::rast() |> 
                terra::aggregate(10, fun = "mean", na.rm = TRUE) |> # aggregate first
                terra::resample(y = terra::rast(dems_target), method = "cubicspline") |> # resample to original resolution
                terra::terrain(v = c("slope", "aspect", "TPI", "TRI"),
                               filename = paste0(args[5], cluster_huc_name, "_terrain_", args[4], "_10m.tif"),
                               overwrite = TRUE)
            dems_target |> 
                terra::rast() |> 
                terra::aggregate(100, fun = "mean", na.rm = TRUE) |> # aggregate first
                terra::resample(y = terra::rast(dems_target), method = "cubicspline") |> # resample to original resolution
                terra::terrain(v = c("slope", "aspect", "TPI", "TRI"),
                               filename = paste0(args[5], cluster_huc_name, "_terrain_", args[4], "_100m.tif"),
                               overwrite = TRUE)
            dems_target |> 
                terra::rast() |> 
                terra::aggregate(1000, fun = "mean", na.rm = TRUE) |> # aggregate first
                terra::resample(y = terra::rast(dems_target), method = "cubicspline") |> # resample to original resolution
                terra::terrain(v = c("slope", "aspect", "TPI", "TRI"),
                               filename = paste0(args[5], cluster_huc_name, "_terrain_", args[4], "_1000m.tif"),
                               overwrite = TRUE)
        } else if (stringr::str_detect(metric, "dmv")){
            dems_target |> 
                terra::rast() |> 
                terra::aggregate(10, fun = "mean", na.rm = TRUE) |> # aggregate first
                terra::resample(y = terra::rast(dems_target), method = "cubicspline") |> # resample to original resolution
                MultiscaleDTM::DMV(w = c(3,3), stand = "none", # I think "none" so that NA won't be produced
                                   include_scale = FALSE,
                                      filename = paste0(args[5], cluster_huc_name, "_terrain_", args[4], "_10m.tif"),
                                      overwrite = TRUE) 
            dems_target |> 
                terra::rast() |> 
                terra::aggregate(100, fun = "mean", na.rm = TRUE) |> # aggregate first
                terra::resample(y = terra::rast(dems_target), method = "cubicspline") |> # resample to original resolution
                MultiscaleDTM::DMV(w = c(3,3), stand = "none", # I think "none" so that NA won't be produced
                                   include_scale = FALSE,
                                   filename = paste0(args[5], cluster_huc_name, "_terrain_", args[4], "_100m.tif"),
                                   overwrite = TRUE) 
            dems_target |> 
                terra::rast() |> 
                terra::aggregate(1000, fun = "mean", na.rm = TRUE) |> # aggregate first
                terra::resample(y = terra::rast(dems_target), method = "cubicspline") |> # resample to original resolution
                MultiscaleDTM::DMV(w = c(3,3), stand = "none", # I think "none" so that NA won't be produced
                                   include_scale = FALSE,
                                   filename = paste0(args[5], cluster_huc_name, "_terrain_", args[4], "_1000m.tif"),
                                   overwrite = TRUE) 
        } else if(stringr::str_detect(metric, "curv")){
            dems_target |> 
                terra::rast() |> 
                terra::aggregate(10, fun = "mean", na.rm = TRUE) |> # aggregate first
                terra::resample(y = terra::rast(dems_target), method = "cubicspline") |> # resample to original resolution
                MultiscaleDTM::Qfit(w = c(3,3),
                                    include_scale = TRUE, metrics = c("meanc", "planc", "profc"),
                                    filename = paste0(args[5], cluster_huc_name, huc_name, "_terrain_", args[4], "_10m.tif"),
                                    overwrite = TRUE)
            dems_target |> 
                terra::rast() |> 
                terra::aggregate(100, fun = "mean", na.rm = TRUE) |> # aggregate first
                terra::resample(y = terra::rast(dems_target), method = "cubicspline") |> # resample to original resolution
                MultiscaleDTM::Qfit(w = c(3,3),
                                    include_scale = TRUE, metrics = c("meanc", "planc", "profc"),
                                    filename = paste0(args[5], cluster_huc_name, huc_name, "_terrain_", args[4], "_100m.tif"),
                                    overwrite = TRUE)
            dems_target |> 
                terra::rast() |> 
                terra::aggregate(1000, fun = "mean", na.rm = TRUE) |> # aggregate first
                terra::resample(y = terra::rast(dems_target), method = "cubicspline") |> # resample to original resolution
                MultiscaleDTM::Qfit(w = c(3,3),
                                    include_scale = TRUE, metrics = c("meanc", "planc", "profc"),
                                    filename = paste0(args[5], cluster_huc_name, huc_name, "_terrain_", args[4], "_1000m.tif"),
                                    overwrite = TRUE)
        } else {
            print("No terrain metric specified or not identified")
        }
        
        #rm(c("cluster_huc_name", "dems_target"))
    }
    stopCluster(cl)
}
```

```{r}
test_metrics10 <- rast(here("Data/TerrainProcessed/HUC_TerrainMetrics/cluster_208_huc_041402011002_terrain_slp_10m.tif"))
test_metrics100 <- rast(here("Data/TerrainProcessed/HUC_TerrainMetrics/cluster_208_huc_041402011002_terrain_slp_100m.tif"))
test_metrics1000 <- rast(here("Data/TerrainProcessed/HUC_TerrainMetrics/cluster_208_huc_041402011002_terrain_slp_1000m.tif"))


plot(c(test_metrics10$slope,test_metrics100$slope, test_metrics1000$slope), nc = 3)
```

