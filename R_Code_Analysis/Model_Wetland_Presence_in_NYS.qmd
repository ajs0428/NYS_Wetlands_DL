---
title: "Modeling Wetland Presence in NYS"
format: html
---

```{r}
#| label: setup
#| warning: false
library(terra)
library(sf)
suppressPackageStartupMessages(library(tidyterra))
suppressPackageStartupMessages(library(tidyverse))
library(tidymodels)
library(bundle)
library(vip)
library(bestNormalize)
library(here)

here()

theme_param <- theme(
    text = element_text(size = 14),
    legend.position = 'right', 
    legend.key.size = unit(1, "cm"),
    legend.spacing.x = unit(1.2, "cm"),
    legend.text = element_text(size = rel(0.70), hjust = 0.5),
    panel.background = element_blank(),
    panel.grid.major = element_line(colour = "grey80", linewidth = 0.5),
    axis.ticks = element_blank(),
    axis.text = element_text(size = rel(0.8)),
    axis.title = element_text(size = rel(1))
    )

```

## Before starting

### The data to have before modeling

-   Multiscale terrain metrics
    -   Preferably:
        -   slope
        -   curvature (multiple)
        -   deviation from mean elevation
    -   Considering the 1m resolution, these should be calculated at a larger scale
-   Hydrology metrics based on terrain characteristics
    -   Depth to water
        -   This one is tricky and depends on calculation
    -   Topographic wetness index
-   Spectral metrics/indices
    -   For NYS, resolution is 1m so the fine resolution imagery from NAIP would fit best
        -   NDVI
        -   NDWI
    -   Other satellite imagery could include Sentinel (10m) which has more bands
        -   EVI
        -   MNDWI

Other options for data could include some of the following 

- Terrain 
    - Roughness
    - Topographic position index 
- Hydrology 
    - Process model outputs 
    - Flow direction or accumulation 
- Other land characteristics 
    - landforms
    - geology
    - soil 
- Vegetation 
    - land cover classes


## Merging training data from separate clusters


Training data points generated from extracting predictor data from HUC rasters

```{r}
clusters <- c(11, 12, 22, 51, 53, 56, 60, 64, 67, 84, 86, 90, 92, 102, 105, 116, 120, 123, 136, 138, 152, 176, 183, 189, 192, 193, 198, 208, 218, 225, 250)

list_of_pts_extracted_locs <- list.files(here("Data/Training_Data/HUC_Extracted_Training_Data/"), pattern = ".gpkg$", full.names = TRUE, recursive = FALSE)
list_of_pts_extracted <- lapply(list_of_pts_extracted_locs, st_read, quiet = TRUE) |> 
    bind_rows()

nrow(list_of_pts_extracted)
names(list_of_pts_extracted)

list_of_pts_extracted |> 
    mutate(ID = paste0(MOD_CLASS, row_number())) |> 
    select(ID, MOD_CLASS, COARSE_CLASS, huc, cluster, geom) |> st_write(here("Data/Training_Data/FieldSite_Clusters_All_Pts.gpkg"), append = FALSE)
```


NA checking 

```{r}
clusters <- str_extract(list_of_pts_extracted_locs, "(?<=cluster_)\\d+") |> unique()

# df <- pts_extracted_filtered |> 
#         filter((huc %in% c("043001040302", "043001060503", "043001060504",
#                             "043001081302", "043001081401", "043001081402",
#                             "043001081602", "043001081604")))


eval_na_df <- data.frame()

for(j in clusters){
    clust_df <- list_of_pts_extracted_locs[str_detect(list_of_pts_extracted_locs,
                                                      paste0("cluster_", j, "_"))] |>
        lapply(st_read, quiet = TRUE) |> 
        bind_rows() |> 
        as_tibble()
    na_df <- clust_df %>% summarise(across(everything(), ~sum(is.na(.))))
    na_df$cluster <- j
    na_df <- na_df |> select(cluster, everything())
    eval_na_df <- bind_rows(na_df, eval_na_df)
}

eval_na_df |> arrange(desc(DEM))

```


Filter out some of the dat classified as UPL using the wetland delineations datasets

```{r}
nys_delin_upl <- st_read(here("Data/NYS_NHP_Wetland_DelineatonData/NYNHP_NatComm_data/NYSWetlands_NYNHP_NatComm_data_combined.gpkg")) |> 
    filter(COARSE_CLASS == "UPL")
nys_delin_wet <- st_read(here("Data/NYS_NHP_Wetland_DelineatonData/NYNHP_NatComm_data/NYSWetlands_NYNHP_NatComm_data_combined.gpkg")) |> 
    filter(COARSE_CLASS == "WET")


list_of_pts_extracted_wet <- list_of_pts_extracted[list_of_pts_extracted$COARSE_CLASS == "WET", ]
list_of_pts_extracted_upl <- list_of_pts_extracted[list_of_pts_extracted$COARSE_CLASS == "UPL", ]
wet_in_upl <- list_of_pts_extracted_wet[!st_intersects(list_of_pts_extracted_wet, nys_delin_upl) |> lengths(), ]
upl_in_wet <- list_of_pts_extracted_upl[!st_intersects(list_of_pts_extracted_upl, nys_delin_wet) |> lengths(), ]

pts_extracted_filtered <- bind_rows(wet_in_upl, upl_in_wet) |>
    mutate(ID = paste0(MOD_CLASS, row_number()))
nrow(pts_extracted_filtered)
```



```{r}
pts_extracted_filtered |> as_tibble() |> group_by(MOD_CLASS) |> summarise(n = n())
pts_extracted_filtered |> as_tibble() |> group_by(COARSE_CLASS) |> summarise(n = n())

df <- pts_extracted_filtered |> 
        filter((huc %in% c("043001040302", "043001060503", "043001060504",
                            "043001081302", "043001081401", "043001081402",
                            "043001081602", "043001081604")))
ndf <- nrow(df)
# for(i in names(pts_extracted_filtered)){
#     na_rows <- df |> filter(is.na(.data[[i]])) |> nrow()
#     print(paste0(i, ": ", round(na_rows/ndf, 2)))
# }
```




```{r}
pts_extracted_df <- as_tibble(pts_extracted_filtered) |> 
    # filter(!(cluster %in% c(198))) |> 
    # select(1:38, ID) |> 
    dplyr::mutate(across(where(is.character), as.factor),
                  twi = case_when(is.infinite(twi) ~ NA,
                                  # is.nan(twi) ~ 0,
                                  .default = twi)
                  ) |> 
    drop_na()

names(pts_extracted_df)
nrow(pts_extracted_df)

pts_extracted_df |> group_by(MOD_CLASS) |> reframe(mean = mean(CHM),
                                                   n = n())
```

### Data exploration

```{r}
cluster_df_pca <- pts_extracted_df |> 
    # filter(MOD_CLASS != "UPL") |> 
    # dplyr::select(where(is.numeric)) |>
    filter(if_all(is.numeric, is.finite)) 

pc <- prcomp(cluster_df_pca |> select(where(is.numeric)),
             center = TRUE,
            scale. = TRUE)

ggbiplot::ggbiplot(pc, point.size = 0.1,
                   alpha = 0.1,
              obs.scale = 1,
              var.scale = 1, var.axes = FALSE,
              groups = cluster_df_pca$COARSE_CLASS,
              ellipse = TRUE,
              #circle = TRUE,circle.prob = 0.68,
              ellipse.prob = 0.99)
```

```{r}
pts_extracted_df |> 
    mutate(across(where(is.numeric), ~ scale(.x))) |> 
    group_by(MOD_CLASS) |> 
    pivot_longer(c(slope_500m, slope_5m), names_to = "metric", values_to = "value") |> 
    ggplot(aes(x = MOD_CLASS)) +
    geom_violin(aes(y = value, fill = metric)) +
    theme_param

pts_extracted_df |> 
    mutate(across(where(is.numeric), ~ scale(.x))) |> 
    group_by(MOD_CLASS) |> 
    pivot_longer(c(CHM), names_to = "metric", values_to = "value") |> 
    ggplot(aes(x = MOD_CLASS)) +
    geom_violin(aes(y = value, fill = metric)) +
    theme_param

pts_extracted_df |> 
    mutate(across(where(is.numeric), ~ scale(.x))) |> 
    group_by(MOD_CLASS) |> 
    pivot_longer(c(twi), names_to = "metric", values_to = "value") |> 
    ggplot(aes(x = MOD_CLASS)) +
    geom_violin(aes(y = value, fill = metric), draw_quantiles = 0.5) +
    theme_param

pts_extracted_df |> 
    mutate(across(where(is.numeric), ~ scale(.x))) |> 
    group_by(MOD_CLASS) |> 
    pivot_longer(c(ndwi, ndvi), names_to = "metric", values_to = "value") |> 
    ggplot(aes(x = MOD_CLASS)) +
    geom_violin(aes(y = (value), fill = metric), draw_quantiles = 0.5) +
    #geom_jitter(aes(y = (value)), alpha = 0.05, width = 0.1) +
    theme_param

pts_extracted_df |> 
    mutate(across(where(is.numeric), ~ scale(.x))) |> 
    group_by(MOD_CLASS) |> 
    pivot_longer(c(r, nir), names_to = "metric", values_to = "value") |> 
    ggplot(aes(x = MOD_CLASS)) +
    geom_violin(aes(y = value, fill = metric), draw_quantiles = 0.5) +
    theme_param
```




Training/Testing split
```{r}
set.seed(11)

data_split <- initial_split(pts_extracted_df, prop = 3/4)

# Create data frames for the two sets:
train_data <- training(data_split) |> 
    filter(!(MOD_CLASS == "OWW" & CHM > 1))
    # filter(!(MOD_CLASS == "EMW" & CHM > 4)) |> 
    # filter(!(MOD_CLASS == "SSW" & CHM > 6)) #|> 
    # filter(!(MOD_CLASS == "FSW" & CHM < 3))
test_data  <- testing(data_split) |> 
    filter(!(MOD_CLASS == "OWW" & CHM > 1))

readr::write_csv(train_data, here("Data/Dataframes/draftTrainingPoints.csv"))
readr::write_csv(test_data, here("Data/Dataframes/draftTestPoints.csv"))

glimpse(train_data)
```


```{r}
#| eval: false
Wetland_Multi_Recipe <- 
    recipe(MOD_CLASS ~ ., data = train_data |> select(-ID, -COARSE_CLASS, -cluster, -huc, -geom)) 
Wetland_Coarse_Recipe <- 
    recipe(COARSE_CLASS ~ ., data = train_data |> select(-ID, -MOD_CLASS, -cluster, -huc, -geom)) 


RFM <- 
    rand_forest(
        mtry = ncol(train_data|> select(-ID))-5,
        trees = 100,
        min_n = 3
    ) |> 
    set_engine(
        "ranger", 
        num.threads = 24,
        seed = 11,
        importance = "permutation"
        #probability = TRUE
        ) |> 
    set_mode("classification") 
# BT <- 
#     boost_tree(mode = "classification", 
#                mtry = ncol(train_data|> select(-ID))-2,
#                trees = 500,
#                min_n = 3,
#                learn_rate = 0.1) |> 
#     set_engine("xgboost",
#                eval_metric = "rmse")

RFM_multi_workflow <- 
    workflow() |> 
    add_model(RFM) |> 
    add_recipe(Wetland_Multi_Recipe)
RFM_coarse_workflow <- 
    workflow() |> 
    add_model(RFM) |> 
    add_recipe(Wetland_Coarse_Recipe)
# BT_multi_workflow <- 
#     workflow() |> 
#     add_model(BT) |> 
#     add_recipe(Wetland_Multi_Recipe)

system.time({RFM_multi_fit <- 
    RFM_multi_workflow |>
    fit(train_data |> select(-ID, -COARSE_CLASS, -cluster, -huc, -geom))})
system.time({RFM_coarse_fit <- 
    RFM_coarse_workflow |>
    fit(train_data |> select(-ID, -MOD_CLASS, -cluster, -huc, -geom))})
# system.time({BT_multi_fit <- 
#     BT_multi_workflow |>
#     fit(train_data |> select(-ID, -COARSE_CLASS, -huc))})

saveRDS(bundle(RFM_multi_fit), here("Data/Models/draftMultiClass_RFM.rds"))
saveRDS(bundle(RFM_coarse_fit), here("Data/Models/draftCoarseClass_RFM.rds"))
```


```{r}
RFM_multi_fit <- unbundle(readRDS(here("Data/Models/draftMultiClass_RFM.rds")))
RFM_coarse_fit <- unbundle(readRDS(here("Data/Models/draftCoarseClass_RFM.rds")))

RFM_multi_fit |> 
    extract_fit_parsnip() |> 
    vip(num_features = 10) + 
    ggtitle("MultiClass") +
    theme_minimal()
RFM_coarse_fit |> 
    extract_fit_parsnip() |> 
    vip(num_features = 10) + 
    ggtitle("CoarseClass") +
    theme_minimal()

Wetland_MultiTest_Fit <- 
    augment(RFM_multi_fit, test_data)
Wetland_CoarseTest_Fit <- 
    augment(RFM_coarse_fit, test_data)

cluster_test_pts <- Wetland_MultiTest_Fit |> 
    select(ID, dplyr::starts_with(".pred")) |> 
    # dplyr::mutate(ID = paste0(MOD_CLASS, row_number())) |> 
    left_join(y = pts_extracted_filtered, 
               by = join_by(ID)) |> 
    select(ID, dplyr::starts_with(".pred"), MOD_CLASS, COARSE_CLASS, geom) |> 
    mutate(AGREE = case_when(.pred_class == MOD_CLASS ~ "YES",
                             .default = "NO")) |> 
    st_as_sf()
st_write(cluster_test_pts, here("Data/Validation_Test_Data/CoarseClass_Test_Data.gpkg"), append = FALSE)
```


```{r}
cmMulti <- conf_mat(data = Wetland_MultiTest_Fit, truth = MOD_CLASS, estimate = .pred_class) 
cmCoarse <- conf_mat(data = Wetland_CoarseTest_Fit, truth = COARSE_CLASS, estimate = .pred_class) 

cmMulti
cmCoarse

cmMulti |> summary()
cmCoarse |> summary()
```

```{r}
RFM_test_pts <- cluster_test_pts |> 
    as_tibble() |> 
    # filter(MOD_CLASS != "UPL") |> 
    # dplyr::select(where(is.numeric)) |>
    filter(if_all(is.numeric)) 

RFM_test_pc <- prcomp(RFM_test_pts |> select(where(is.numeric)),
             center = TRUE,
            scale. = TRUE)

ggbiplot::ggbiplot(RFM_test_pc, point.size = 0.1,
                   alpha = 0.1,
              obs.scale = 1,
              var.scale = 1, var.axes = FALSE,
              groups = RFM_test_pts$AGREE,
              ellipse = TRUE,
              #circle = TRUE,circle.prob = 0.68,
              ellipse.prob = 0.75)
```


```{r}
cluster_test_pts |> 
    # filter(AGREE == "NO") |> 
    group_by(MOD_CLASS) |> 
    reframe(n = n()) 

cluster_test_pts |> 
    filter(AGREE == "NO") |> 
    group_by(MOD_CLASS) |> 
    reframe(n = n()) 
```

