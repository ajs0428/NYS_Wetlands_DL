---
title: "Modeling Wetland Presence in NYS"
format: html
---

```{r}
#| label: setup
#| warning: false
library(terra)
library(sf)
suppressPackageStartupMessages(library(tidyterra))
suppressPackageStartupMessages(library(tidyverse))
library(tidymodels)
library(bundle)
library(vip)
library(bestNormalize)
library(here)

here()

terraOptions(memfrac = 0.50,# Use only 10% of memory for program
             memmax = 64, #max memory is 8Gb
             tempdir = "/ibstorage/anthony/NYS_Wetlands_GHG/Data/tmp")

theme_param <- theme(
    text = element_text(size = 14),
    legend.position = 'right', 
    legend.key.size = unit(1, "cm"),
    legend.spacing.x = unit(1.2, "cm"),
    legend.text = element_text(size = rel(0.70), hjust = 0.5),
    panel.background = element_blank(),
    panel.grid.major = element_line(colour = "grey80", linewidth = 0.5),
    axis.ticks = element_blank(),
    axis.text = element_text(size = rel(0.8)),
    axis.title = element_text(size = rel(1))
    )

```

## Before starting

### The data to have before modeling

-   Multiscale terrain metrics
    -   Preferably:
        -   slope
        -   curvature (multiple)
        -   deviation from mean elevation
    -   Considering the 1m resolution, these should be calculated at a scale greater than the 3x3 window
        -   11x11, 21x21, 51x51
        -   Note that increases in the window size greatly increase computation time
-   Hydrology metrics based on terrain characteristics
    -   Depth to water
        -   This one is tricky and depends on calculation
    -   Topographic wetness index
-   Spectral metrics/indices
    -   For NYS, resolution is 1m so the fine resolution imagery from NAIP would fit best
        -   NDVI
        -   NDWI
    -   Other satellite imagery could include Sentinel (10m) which has more bands
        -   EVI
        -   MNDWI

Other options for data could include some of the following - Terrain - Roughness - Topographic position index - Hydrology - Process model outputs - Flow direction or accumulation - Other land characteristics - landforms - geology - soil - Vegetation - land cover classes


## Modeling for cluster 208 


HUCS

```{r}
cluster_target <- sf::st_read(here("Data/NY_HUCS/NY_Cluster_Zones_200.gpkg"), quiet = TRUE) |> 
    sf::st_transform(sf::st_crs("EPSG:6347")) |>
    dplyr::filter(cluster == 208) 
plot(cluster_target["huc12"])

cluster_pts <- st_read(here("Data/Training_Data/Cluster_Extract_Training_Pts/cluster_208_extracted_training_pts.gpkg")) 


cluster_pts |> as_tibble() |> group_by(MOD_CLASS) |> summarise(n = n())
cluster_pts |> as_tibble() |> group_by(COARSE_CLASS) |> summarise(n = n())

plot(st_geometry(cluster_target))
plot(cluster_pts["MOD_CLASS"], add = TRUE)
```




```{r}
cluster_df <- as_tibble(cluster_pts) |> 
    dplyr::mutate(across(where(is.character), as.factor),
                  ID = paste0(MOD_CLASS, row_number()),
                  twi = case_when(is.infinite(twi) ~ 11.8,
                                  is.nan(twi) ~ 0,
                                  .default = twi)) |> 
    dplyr::select(MOD_CLASS, COARSE_CLASS, ID, everything(), -geom)

cluster_df
```

### Data exploration

```{r}
cluster_df_pca <- cluster_df |> 
    #dplyr::select(-MOD_CLASS, -ID) |>
    filter(if_all(is.numeric, is.finite))

pc <- prcomp(cluster_df_pca |> select(-MOD_CLASS, -ID, -COARSE_CLASS,
                                      -starts_with("aspect")),
             center = TRUE,
            scale. = TRUE)

ggbiplot::ggbiplot(pc,
              obs.scale = 1,
              var.scale = 1,
              groups = cluster_df_pca$MOD_CLASS,
              ellipse = TRUE,
              #circle = TRUE,
              ellipse.prob = 0.68)

```

```{r}
cluster_df |> 
    mutate(across(where(is.numeric), ~ scale(.x))) |> 
    group_by(MOD_CLASS) |> 
    pivot_longer(c(slope_500m, slope_5m), names_to = "metric", values_to = "value") |> 
    ggplot(aes(x = MOD_CLASS)) +
    geom_violin(aes(y = value, fill = metric)) +
    theme_param

cluster_df |> 
    mutate(across(where(is.numeric), ~ scale(.x))) |> 
    group_by(MOD_CLASS) |> 
    pivot_longer(c(profc_500m, profc_5m), names_to = "metric", values_to = "value") |> 
    ggplot(aes(x = MOD_CLASS)) +
    geom_violin(aes(y = value, fill = metric)) +
    theme_param

cluster_df |> 
    mutate(across(where(is.numeric), ~ scale(.x))) |> 
    group_by(MOD_CLASS) |> 
    pivot_longer(c(twi), names_to = "metric", values_to = "value") |> 
    ggplot(aes(x = MOD_CLASS)) +
    geom_violin(aes(y = value, fill = metric), draw_quantiles = 0.5) +
    theme_param

cluster_df |> 
    mutate(across(where(is.numeric), ~ scale(.x))) |> 
    group_by(MOD_CLASS) |> 
    pivot_longer(c(r, nir), names_to = "metric", values_to = "value") |> 
    ggplot(aes(x = MOD_CLASS)) +
    geom_violin(aes(y = value, fill = metric), draw_quantiles = 0.5) +
    theme_param
```




Training/Testing split
```{r}
set.seed(11)

data_split <- initial_split(cluster_df, prop = 3/4)

# Create data frames for the two sets:
train_data <- training(data_split)
test_data  <- testing(data_split)

readr::write_csv(train_data, here("Data/Dataframes/Cluster_208_training_data.csv"))
readr::write_csv(test_data, here("Data/Dataframes/Cluster_208_test_data.csv"))

glimpse(train_data)
```


```{r}
#| eval: false
Wetland_Multi_Recipe <- 
    recipe(MOD_CLASS ~ ., data = train_data |> select(-ID, -COARSE_CLASS)) 
Wetland_Coarse_Recipe <- 
    recipe(COARSE_CLASS ~ ., data = train_data |> select(-ID, -MOD_CLASS)) 


RFM <- 
    rand_forest(
        mtry = ncol(train_data|> select(-ID))-2,
        trees = 500,
        min_n = 5
    ) |> 
    set_engine(
        "ranger", 
        num.threads = 24,
        seed = 11,
        importance = "permutation"
        #probability = TRUE
        ) |> 
    set_mode("classification") 

RFM_multi_workflow <- 
    workflow() |> 
    add_model(RFM) |> 
    add_recipe(Wetland_Multi_Recipe)
RFM_coarse_workflow <- 
    workflow() |> 
    add_model(RFM) |> 
    add_recipe(Wetland_Coarse_Recipe)

system.time({RFM_multi_fit <- 
    RFM_multi_workflow |>
    fit(train_data |> select(-ID, -COARSE_CLASS))})
system.time({RFM_coarse_fit <- 
    RFM_coarse_workflow |>
    fit(train_data|> select(-ID, -MOD_CLASS))})

saveRDS(bundle(RFM_multi_fit), here("Data/Models/Cluster_208_MultiClass_RFM.rds"))
saveRDS(bundle(RFM_coarse_fit), here("Data/Models/Cluster_208_CoarseClass_RFM.rds"))
```


```{r}
RFM_multi_fit <- unbundle(readRDS(here("Data/Models/Cluster_208_MultiClass_RFM.rds")))
RFM_coarse_fit <- unbundle(readRDS(here("Data/Models/Cluster_208_CoarseClass_RFM.rds")))

RFM_multi_fit |> 
    extract_fit_parsnip() |> 
    vip(num_features = 10) + 
    ggtitle("MultiClass") +
    theme_minimal()
RFM_coarse_fit |> 
    extract_fit_parsnip() |> 
    vip(num_features = 10) + 
    ggtitle("CoarseClass") +
    theme_minimal()

Wetland_MultiTest_Fit <- 
    augment(RFM_multi_fit, test_data)
Wetland_CoarseTest_Fit <- 
    augment(RFM_coarse_fit, test_data)

cluster_test_pts <- cluster_pts |> 
    dplyr::mutate(ID = paste0(MOD_CLASS, row_number())) |> 
    right_join(y = Wetland_CoarseTest_Fit |> select(ID, .pred_class, .pred_WET), by = join_by(ID))
st_write(cluster_test_pts, here("Data/Validation_Test_Data/Cluster_208_CoarseClass_Test_Data.gpkg"), append = FALSE)
```


```{r}
cmMulti <- conf_mat(data = Wetland_MultiTest_Fit, truth = MOD_CLASS, estimate = .pred_class) 
cmCoarse <- conf_mat(data = Wetland_CoarseTest_Fit, truth = COARSE_CLASS, estimate = .pred_class) 

cmMulti
cmCoarse

cmMulti |> summary()
cmCoarse |> summary()
```

```{r}

```

